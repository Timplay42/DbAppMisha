"""add all trigger

Revision ID: 7c31029a1d82
Revises: 6e0961388656
Create Date: 2026-01-21 12:10:01.725022

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '7c31029a1d82'
down_revision: Union[str, Sequence[str], None] = '6e0961388656'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None

def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###

    # 1. Триггер для проверки удаления водителя
    op.execute("""
    CREATE OR REPLACE FUNCTION check_driver_deletion()
    RETURNS TRIGGER AS $$
    BEGIN
        -- Проверяем, есть ли у водителя активные перевозки (не доставленные и не отмененные)
        IF EXISTS (
            SELECT 1 
            FROM shipment 
            WHERE driver_id = OLD.id 
              AND status IN ('pending', 'in_transit')
        ) THEN
            RAISE EXCEPTION 'Невозможно удалить водителя. У него есть активные перевозки (в пути или ожидающие).';
        END IF;

        RETURN OLD;
    END;
    $$ LANGUAGE plpgsql;
    """)

    op.execute("""
    DROP TRIGGER IF EXISTS prevent_driver_deletion ON driver;
    CREATE TRIGGER prevent_driver_deletion
        BEFORE DELETE ON driver
        FOR EACH ROW
        EXECUTE FUNCTION check_driver_deletion();
    """)

    # 2. Триггер для проверки дат тарифа
    op.execute("""
    CREATE OR REPLACE FUNCTION check_tariff_dates()
    RETURNS TRIGGER AS $$
    BEGIN
        -- Проверяем, что дата окончания (если указана) больше даты начала
        IF NEW.date_end IS NOT NULL AND NEW.date_end <= NEW.date_start THEN
            RAISE EXCEPTION 'Дата окончания тарифа должна быть позже даты начала. Дата начала: %, Дата окончания: %', 
                            NEW.date_start, NEW.date_end;
        END IF;

        -- Проверяем, что дата начала не в прошлом (опционально)
        IF NEW.date_start < CURRENT_DATE THEN
            RAISE WARNING 'Дата начала тарифа в прошлом: %.', NEW.date_start;
        END IF;

        RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;
    """)

    op.execute("""
    DROP TRIGGER IF EXISTS validate_tariff_dates ON tariff;
    CREATE TRIGGER validate_tariff_dates
        BEFORE INSERT OR UPDATE ON tariff
        FOR EACH ROW
        EXECUTE FUNCTION check_tariff_dates();
    """)

    # 3. Триггер для проверки стажа водителя
    op.execute("""
    CREATE OR REPLACE FUNCTION check_driver_experience()
    RETURNS TRIGGER AS $$
    DECLARE
        current_date_val DATE := CURRENT_DATE;
        driver_age_years INTEGER;
        hire_date_age_years INTEGER;
    BEGIN
        -- Проверяем стаж через поле experience_years
        IF NEW.experience_years > 40 THEN
            RAISE EXCEPTION 'Стаж водителя не может превышать 40 лет. Указано: % лет.', NEW.experience_years;
        END IF;

        -- Дополнительная проверка: если указана дата приема, проверяем по ней
        IF NEW.hire_date IS NOT NULL THEN
            hire_date_age_years := EXTRACT(YEAR FROM AGE(current_date_val, NEW.hire_date));

            IF hire_date_age_years > 40 THEN
                RAISE EXCEPTION 'По дате приема стаж водителя превышает 40 лет. Стаж: % лет (дата приема: %).', 
                                hire_date_age_years, NEW.hire_date;
            END IF;

            -- Согласованность данных: проверяем, что experience_years не сильно отличается от реального стажа
            IF ABS(NEW.experience_years - hire_date_age_years) > 5 THEN
                RAISE WARNING 'Стаж водителя (указано: % лет) сильно отличается от стажа по дате приема (рассчитано: % лет).', 
                              NEW.experience_years, hire_date_age_years;
            END IF;
        END IF;

        RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;
    """)

    op.execute("""
    DROP TRIGGER IF EXISTS validate_driver_experience ON driver;
    CREATE TRIGGER validate_driver_experience
        BEFORE INSERT OR UPDATE ON driver
        FOR EACH ROW
        EXECUTE FUNCTION check_driver_experience();
    """)

    # 4. Функция для предотвращения удаления таблиц
    op.execute("""
    CREATE OR REPLACE FUNCTION prevent_table_drop()
    RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
    DECLARE
        obj record;
    BEGIN
        FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
        LOOP
            -- Запрещаем удаление таблицы shipment
            IF obj.object_type = 'table' AND obj.object_name = 'shipment' THEN
                RAISE EXCEPTION 'Удаление таблицы shipment запрещено!';
            END IF;

            -- Запрещаем удаление других важных таблиц
            IF obj.object_type = 'table' AND obj.object_name IN ('driver', 'car', 'route', 'tariff') THEN
                RAISE EXCEPTION 'Удаление таблицы % запрещено!', obj.object_name;
            END IF;
        END LOOP;
    END;
    $$;
    """)

    op.execute("""
    DROP EVENT TRIGGER IF EXISTS prevent_important_drops;
    CREATE EVENT TRIGGER prevent_important_drops
        ON sql_drop
        EXECUTE FUNCTION prevent_table_drop();
    """)

    # 5. Функция для проверки защиты таблиц
    op.execute("""
    CREATE OR REPLACE FUNCTION check_table_protection()
    RETURNS TABLE(
        table_name TEXT,
        is_protected BOOLEAN,
        trigger_exists BOOLEAN
    )
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
        SELECT 
            t.table_name::TEXT,
            t.table_name IN ('shipment', 'driver', 'car', 'route', 'tariff') as is_protected,
            EXISTS (
                SELECT 1 FROM pg_event_trigger 
                WHERE evtname = 'prevent_important_drops'
            ) as trigger_exists
        FROM information_schema.tables t
        WHERE t.table_schema = 'public'
          AND t.table_type = 'BASE TABLE'
          AND t.table_name IN ('shipment', 'driver', 'car', 'route', 'tariff')
        ORDER BY t.table_name;
    END;
    $$;
    """)

    # 6. Добавим дополнительный триггер для проверки грузоподъемности при создании перевозки
    op.execute("""
    CREATE OR REPLACE FUNCTION check_shipment_capacity()
    RETURNS TRIGGER AS $$
    DECLARE
        car_load_capacity_kg FLOAT;
    BEGIN
        -- Получаем грузоподъемность автомобиля (в тоннах) и конвертируем в кг
        SELECT load_capacity * 1000 INTO car_load_capacity_kg
        FROM car
        WHERE id = NEW.car_id;

        -- Проверяем, не превышает ли вес груза грузоподъемность
        IF car_load_capacity_kg IS NOT NULL AND NEW.cargo_weight > car_load_capacity_kg THEN
            RAISE EXCEPTION 'Вес груза (кг) превышает грузоподъемность автомобиля. Груз: % кг, Максимум: % кг', 
                            NEW.cargo_weight, car_load_capacity_kg;
        END IF;

        RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;
    """)

    op.execute("""
    DROP TRIGGER IF EXISTS validate_shipment_capacity ON shipment;
    CREATE TRIGGER validate_shipment_capacity
        BEFORE INSERT OR UPDATE ON shipment
        FOR EACH ROW
        EXECUTE FUNCTION check_shipment_capacity();
    """)

    # 7. Триггер для автоматического обновления total_cost в shipment
    op.execute("""
    CREATE OR REPLACE FUNCTION calculate_shipment_cost()
    RETURNS TRIGGER AS $$
    DECLARE
        route_distance FLOAT;
        tariff_price_per_km FLOAT;
        tariff_min_price FLOAT;
        calculated_cost FLOAT;
    BEGIN
        -- Получаем данные маршрута и тарифа
        SELECT distance_km INTO route_distance
        FROM route
        WHERE id = NEW.route_id;

        SELECT price_per_km, min_price INTO tariff_price_per_km, tariff_min_price
        FROM tariff
        WHERE id = NEW.tariff_id;

        -- Рассчитываем стоимость
        IF route_distance IS NOT NULL AND tariff_price_per_km IS NOT NULL THEN
            calculated_cost := route_distance * tariff_price_per_km;

            -- Применяем минимальную цену
            IF tariff_min_price IS NOT NULL AND calculated_cost < tariff_min_price THEN
                calculated_cost := tariff_min_price;
            END IF;

            NEW.total_cost := calculated_cost;
        END IF;

        RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;
    """)

    op.execute("""
    DROP TRIGGER IF EXISTS auto_calculate_shipment_cost ON shipment;
    CREATE TRIGGER auto_calculate_shipment_cost
        BEFORE INSERT OR UPDATE OF route_id, tariff_id, cargo_weight ON shipment
        FOR EACH ROW
        EXECUTE FUNCTION calculate_shipment_cost();
    """)

    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###

    # Удаляем все созданные триггеры и функции
    op.execute("DROP TRIGGER IF EXISTS prevent_driver_deletion ON driver;")
    op.execute("DROP FUNCTION IF EXISTS check_driver_deletion();")

    op.execute("DROP TRIGGER IF EXISTS validate_tariff_dates ON tariff;")
    op.execute("DROP FUNCTION IF EXISTS check_tariff_dates();")

    op.execute("DROP TRIGGER IF EXISTS validate_driver_experience ON driver;")
    op.execute("DROP FUNCTION IF EXISTS check_driver_experience();")

    op.execute("DROP EVENT TRIGGER IF EXISTS prevent_important_drops;")
    op.execute("DROP FUNCTION IF EXISTS prevent_table_drop();")

    op.execute("DROP FUNCTION IF EXISTS check_table_protection();")

    op.execute("DROP TRIGGER IF EXISTS validate_shipment_capacity ON shipment;")
    op.execute("DROP FUNCTION IF EXISTS check_shipment_capacity();")

    op.execute("DROP TRIGGER IF EXISTS auto_calculate_shipment_cost ON shipment;")
    op.execute("DROP FUNCTION IF EXISTS calculate_shipment_cost();")

    # ### end Alembic commands ###